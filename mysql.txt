mysql   

1.级联查询后更新  可以用来修数据
update tb1,
(select * from tb2) as tb2
set tb1.a=tb2.a,tb1.b=tb2.b
where tb1.id=tb2.id

2.建索引的几大原则   (https://tech.meituan.com/mysql-index.html)
(1)最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>,<,between,like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
(2)=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
(3)尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
(4)索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
(5)尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可

3.慢查询优化基本步骤
(1)先运行看看是否真的很慢，注意设置SQL_NO_CACHE
(2)where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
(3)explain查看执行计划，是否与2预期一致（从锁定记录较少的表开始查询）
(4)order by limit 形式的sql语句让排序的表优先查


索引优化
1.不要在列上使用函数和进行运算（不要在列上使用函数，这将导致索引失效而进行全表扫描。）
2.负向条件查询不能使用索引（负向条件有：!=、<>、not in、not exists、not like 等）
3.范围列可以用到索引（范围条件有：<、<=、>、>=、between等））（范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引）
4.更新频繁、数据区分度不高的字段上不宜建立索引（更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能，「性别」这种区分度不大的属性，建立索引没有意义，不能有效过滤数据，性能与全表扫描类似,区分度可以使用 count(distinct(列名))/count(*) 来计算，在80%以上的时候就可以建立索引）
5.索引列不允许为null
6.避免使用or来连接条件(应该尽量避免在 where 子句中使用 or 来连接条件，因为这会导致索引失效而进行全表扫描，虽然新版的MySQL能够命中索引，但查询优化耗费的 CPU比in多)
7.模糊查询(前导模糊查询不能使用索引，非前导查询可以)
8.












